rd_("AjContains the success valueAhContains the error valueAiGet a page from the cacheAeGet the current valueAbGet value at indexAiPrimary key of the recordAdGet the current sizeBdGet the current length (approximate)AhGet the number of valuesClCreate a new DAX VFS The file should be on a DAX-enabled \xe2\x80\xa6AjPop an item from the queueoSet a new valueAbSet value at indexAbActual data valuesAoReturns the argument unchanged.00000000000000000000000000000000000000000000000000000000000000000000000BaCalls <code>U::from(self)</code>.00000000000000000000000000000000000000000000000000000000000000000000000ClKeys array (contiguous, cache-friendly) Using fixed-size \xe2\x80\xa6AbMemory-mapped filejTable nameiFile pathAiPush an item to the queueA`Read log entrieslCurrent sizeAaSync data to diskCjTransaction ID that deleted/updated this version (0 if \xe2\x80\xa6BhTransaction ID that created this versionoClear the cacheAdFlags for node stateAhFlush all pending writesA`Flush all writes1AlLevel in the tree (0 = leaf)CjMerge with another record using Last-Write-Wins (LWW) ruleBhState: table_name -&gt; key -&gt; recordAdGet cache statisticsnGet statisticsAnStatistics for adaptive layoutAgGet the store referenceCkDirect Access (DAX) mode for persistent memory Bypasses \xe2\x80\xa6AkDelete a record (tombstone)BkHybrid: Row-major with columnar projectionsAcInsert a new recordAgNode/replica identifierAiUpdate an existing recordClAppend a log entry (returns immediately after cache line \xe2\x80\xa6oDelete a recordAnMark as deleted with tombstoneBiExpand the file to accommodate more pagesB`Header (64 bytes, cache-aligned)AlInsert a page into the cache8kLayout modenParent page IDAlRemove a page from the cacheBoTransaction ID of this snapshot\xe2\x80\x99s transaction:CmVacuum old versions (garbage collection) Should be called \xe2\x80\xa6CfRemove versions that are no longer needed (garbage \xe2\x80\xa6CiColumn data stored in columnar format for SIMD processingfSchemaCnCache entries: page_id -&gt; cached page Using Arc for the \xe2\x80\xa6AbGet a key at indexA`Get a row by keyAkCheck if the buffer is fullAgCurrent node identifierCdTry to pop an item (returns None if buffer is empty)CnAsynchronous Virtual File System trait Abstracts different \xe2\x80\xa6C`Row-oriented storage (NSM - N-ary Storage Model)BjSnapshot isolation state for a transactionBfStandard Tokio-based async file systemAjPadding to fill cache lineA`Get the capacityB`Maximum number of pages to cacheCkChild pointers for internal nodes (or value offsets for \xe2\x80\xa6AiHelper to get file handleAkCheck if the queue is emptyAlCheck if the buffer is emptynCheck if emptyAkNumber of keys in this nodeBmTry to push an item (fails if buffer is full)ChList of versions ordered by timestamp (oldest to newest)oCRDT statisticsBdCRDT Store managing replicated stateAhI/O request for batchingAfMVCC system statisticsoPMEM statisticsBaRow-oriented record (traditional)B`Timestamp for version visibilityBdBase address for offset calculationsBhRemaining space for values in leaf nodesBbEvict the least recently used pageAlGet a child page ID at indexCmGet statistics about the MVCC system LOCK ORDERING: Level \xe2\x80\xa6nGet statisticsCfCheck if a transaction holds any locks (for debugging)AoIncrement and get the new valueAnLRU tracking queue (lock-free)BaNode type: 0 = internal, 1 = leafoNumber of pagesAgGet the number of pages0AjRead a page asynchronouslyAhRead a page with cachingkRead a pagemGet row countAlNumber of rows in this batchAoPrimary row storage (row-major)mScan all rowsAaSerialize to pageAkGet mutable store referenceBfTimestamp when this snapshot was takenBkAsync Pager that coordinates I/O operationsAkA cached page with metadataAnCRDT State for a single recordAgTable access statisticsAiAdd a column to the batchAbCreation timestampBmDeletion/update timestamp (0 if still active)AeGet a specific recordlInsert a rowCnCheck if this version is visible to a transaction with the \xe2\x80\xa6CfCheck if this version is visible to the given snapshotAoRead multiple pages in parallelBcScan all visible records in a tableCiBinary search using SIMD when available Optimized for \xe2\x80\xa6AeGet the size in bytesAkWrite a page asynchronouslyAjWrite a page through cachelWrite a pageCkColumn-oriented storage (DSM - Decomposition Storage Model)AdHybrid storage tableCkMVCC Manager coordinates snapshot isolation and version \xe2\x80\xa6BnVectorized batch processor for query executionAnVersion visibility informationB`Add a new version to this recordAdGet cache statistics0AeDeserialize from pageAhSynchronization protocolAkA column of vectorized dataCjAcquire a lock on a resource with timeout for deadlock \xe2\x80\xa6CkColumnar projections (column-major, materialized on demand)BjGet a pointer to a page (zero-copy access)BmMark this version as deleted by a transactionBbMark the latest version as deletedAmFind maximum value using SIMDAmFind minimum value using SIMDBiPersist data using cache line flushes \xe2\x80\xa6BeRead a record with snapshot isolationBcSum an array of integers using SIMDBcVector clock for causality trackingA`Version metadataBkColumn-oriented storage for a single columnAdCRDT operation typesCiGlobal transaction ID counter Uses SeqCst ordering to \xe2\x80\xa6AlA single version of a recordAcStorage layout typeAcAllocate a new page00BkExecute a batch of I/O requests in parallelBeApply a vectorized filter to a columnBlInstance-scoped Lamport clock for this storeBaOperation log for synchronizationAjPrefetch a page into cacheAaSet the row countDcVersion store: maps table_name -&gt; key -&gt; versioned record \xe2\x80\xa6BbAsync page cache with LRU evictionB`Count non-null values using SIMDCiDelete a record (creates a new version marked as deleted)B`Insert a new version of a recordC`Get the next Lamport timestamp for this instanceBkBatch I/O executor for improved performanceBcCache line size on most modern CPUsBhPrefetching hints for cache optimizationAfFilter predicate typesBeLock-free counter for transaction IDsB`Lock-free queue for I/O requestsAkLock-free metrics collectorCjA versioned record containing multiple versions of the \xe2\x80\xa6CjDecide whether to use row-major or column-major access \xe2\x80\xa6BeApply a CRDT operation to local stateB`Get the current state of a tableBlInsert a key-child pair (for internal nodes)AkSIMD-accelerated key searchBhLamport timestamp for causality trackingCkVectorized filter operation for WHERE clauses Processes \xe2\x80\xa6CiActive transactions and their snapshots LOCK LEVEL 1: \xe2\x80\xa6AbAggregate a columnBfCalculate average using vectorized sumA`Compare and swapCbGet a mutable pointer to a page (zero-copy writes)CcGet multiple columnar projections as a vector batchA`Get vector clockBeMerge operations from another replicaCdPrune old operations (garbage collection) Remove \xe2\x80\xa6C`Update Lamport clock based on received timestampAhAggregate function typesCnLock-free page cache using crossbeam-epoch for safe memory \xe2\x80\xa6CjVectorized batch size - process this many elements at onceAcAbort a transactionBmBegin a new transaction and create a snapshotChHelper function to get current timestamp in microsecondsBlCurrent timestamp (monotonically increasing)CjCache-conscious B-Tree node layout Keys and values are \xe2\x80\xa6CcLock-free ring buffer for high-throughput scenariosClPMEM-optimized transaction log Uses direct memory access \xe2\x80\xa6AdCommit a transactionBaNon-temporal store (bypass cache)CePrefetch with non-temporal hint (bypass cache for \xe2\x80\xa6BnSet of active transaction IDs at snapshot timeBnGet the visible version for the given snapshotCfTry to acquire read lock with timeout for deadlock \xe2\x80\xa6AcUpdate vector clockBjGet all operations since a given timestampAnProcess sync message from peerAoCache statistics for monitoringClOptimized B-Tree order for cache efficiency Sized to fit \xe2\x80\xa6BaVectorized aggregation operationsAnFilter for equality comparisonBiGenerate sync message for another replicaCbGet a columnar projection (materialized on demand)CnCache-aligned node header Ensures the header fits within a \xe2\x80\xa6CnCommitted transaction timestamps for visibility LOCK LEVEL \xe2\x80\xa6CbCheck if a transaction is visible to this snapshotCmApply a comparison predicate to a batch of integer values \xe2\x80\xa6BdTry to acquire a lock with a timeoutBaAVX2-optimized integer comparisonBfScalar fallback for integer comparison")